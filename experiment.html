<html>

<head>

  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>


  <script>
    // elementary only currently
    var parameters = {
      id: 1,
      title: 'Experiment name',
      reactants: [{
          formula: 'A',
          label0: '[A] = ',
          label1: ' M',
          id: 'reactant_a',
          concentration: 1.0,
          // ---- //
          order: 1,
          stoichiometric_coefficient: 1,
        },
        {
          formula: 'B',
          label0: '[B] = ',
          label1: ' M',
          id: 'reactant_b',
          concentration: 1.0,
          // ---- //
          order: 1,
          stoichiometric_coefficient: 2,
        },
      ],
      products: [{
        formula: 'C',
        label0: '[C] = ',
        label1: ' M',
        id: 'reactant_c',
        concentration: 0.0,
        // ---- //
        order: 1,
        stoichiometric_coefficient: 3,
      }, ],
      rate_constant: 1,
      noise: function() {
        return 1; //  + (Math.random() - 0.5)*1
      },
    };

    var conditions = {
      t: 0.0,
      dt: 0.01,
      Nmax: 500,
    };

    var data = [];
  </script>

</head>

<body>

  Initialize with moodle user id!

  <div id='experimental_conditions'>
    <!-- <div id='reactants'>
      [A] = <input id='reactant_a_initial'> M<br>
      [B] = <input id='reactant_b_initial'> M<br>
    </div> -->
    &Delta;t = <input id='dt'> s<br>
    N<sub>max</sub> = <input id='tmax'><br>

  </div>

  <!-- <button id='add_random'>getData()</button> -->
  <button onclick="loadExperiment()">
    loadExperiment()
  </button>
  <button onclick="calculateData()">
    calculateData()
  </button>
  <button onclick="startExperiment()">
    startExperiment()
  </button>
  <button onclick="plotExperiment()">
    plotExperiment()
  </button>
  <button onclick="getCSVFile()">
    getCSVFile()
  </button>

  <div id="graph"></div>

  <script>
    let range = n => [...Array(n).keys()]


    function loadExperiment() {
      plotly_data = []
      // create initial condition input
      for (r in parameters.reactants) {

        lb0 = document.createTextNode(parameters.reactants[r].label0)
        lb1 = document.createTextNode(parameters.reactants[r].label1)
        inp = document.createElement('input')
        lbr = document.createElement('br')
        inp.value = parameters.reactants[r].concentration;
        inp.id = parameters.reactants[r].id;

        exp = document.getElementById('experimental_conditions');
        exp.appendChild(lb0);
        exp.appendChild(inp);
        exp.appendChild(lb1);
        exp.appendChild(lbr);

        pobj = {
          x: [0.0],
          y: [parameters.reactants[r].concentration],
          type: 'scatter',
          name: parameters.reactants[r].formula,
        }
        plotly_data.push(pobj);

      }

      for (p in parameters.products) {
        pobj = {
          x: [0.0],
          y: [parameters.products[p].concentration],
          type: 'scatter',
          name: parameters.products[p].formula,
        }
        plotly_data.push(pobj);
      }

      // plotly plot
      Plotly.plot('graph', plotly_data, {}, {
        responsive: true,
      });


    }

    function calculateRate(rc) {
      // check if len(rc) > len(parameters.reactants)
      // if equal also a problem...
      s = parameters.rate_constant;
      for (r in parameters.reactants) {
        s = s * Math.pow(rc[r], parameters.reactants[r].order);
      }
      return s;
    }

    function calculateData() {
      // var conditions = {
      //   t: 0.0,
      //   dt: 0.1,
      //   Nmax: 1000,
      // };

      t = conditions.t;
      c = [];
      for (r in parameters.reactants) {
        // for now, later load from textbox
        c.push(parameters.reactants[r].concentration);
      }
      for (p in parameters.products) {
        // for now, later load from textbox
        c.push(parameters.products[p].concentration);
      }

      // START AT 1!
      // data = [];
      data_line = [t].concat(c);
      // console.log(data_line);
      data.push(data_line);
      for (i = 1; i < conditions.Nmax; i++) {
        t = t + conditions.dt;
        s = calculateRate(c);
        c_next = [];
        for (r in parameters.reactants) {
          c_next[r] = c[r] - parameters.noise()*(s * conditions.dt * parameters.reactants[r].stoichiometric_coefficient);
        }
        for (p = 0; p < parameters.products.length; p++) {
          c_next[p + parameters.reactants.length] = c[p + parameters.reactants.length] + parameters.noise()*(s * conditions.dt * parameters.products[p].stoichiometric_coefficient);
        }
        c = c_next;
        data_line = [t].concat(c);
        // console.log(data_line);
        data.push(data_line);
      }
    }

    function plotExperiment() {
      data_x = []
      data_y = []
      for (j = 1; j < data[0].length; j++) {
        temp_x = []
        temp_y = []
        for (i = 0; i < data.length; i++) {
          temp_x.push(data[i][0]);
          temp_y.push(data[i][j]);
        }
        data_x.push(temp_x);
        data_y.push(temp_y);
      }
      console.log(data_x);
      console.log(data_y);
      Plotly.extendTraces('graph', {
        x: data_x,
        y: data_y,
      }, range(data_x.length));
    }

    // plotly 'live' updating
    function startExperiment() {
      setIntervalX(function() {
        Plotly.extendTraces('graph', {
          // do this live
          x: [
            [0.0],
            [0.0],
            [0.0],
          ],
          y: [
            [getData()],
            [getData()],
            [getData()],
          ]
        }, [0, 1, 2])
      }, 100, parameters['max_data_points']);
    }

    // experiment functions

    // returns the current timestep worth of data,
    // including any noise is requested
    // make this a generator
    // function* getData(start = 0, end = 100, step = 1) {
    //   let iterationCount = 0;
    //   for (let i = start; i < end; i += step) {
    //     iterationCount++;
    //     yield i;
    //   }
    //   return iterationCount;
    // }

    function getData() {
      return calcC() + parameters.noise();
    }

    function calcC() {
      return 0
      // calculate rate
      // calculate change
    }


    // helper functions
    function setIntervalX(callback, delay, repetitions) {
      var x = 0;
      var intervalID = window.setInterval(function() {
        callback();
        if (++x === repetitions) {
          window.clearInterval(intervalID);
        }
      }, delay);
    }

    function getCSVFile() {
      // const rows = [
      //     ["name1", "city1", "some other info"],
      //     ["name2", "city2", "more info"]
      // ];

      let csvContent = "data:text/csv;charset=utf-8,";

      data.forEach(function(rowArray) {
          let row = rowArray.join(",");
          csvContent += row + "\r\n";
      });

      // var encodedUri = encodeURI(csvContent);
      // window.open(encodedUri);

      var encodedUri = encodeURI(csvContent);
      var link = document.createElement("a");
      link.setAttribute("href", encodedUri);
      link.setAttribute("download", "my_data.csv");
      document.body.appendChild(link); // Required for FF

      link.click(); // This will download the data file named "my_data.csv".
    }
  </script>

</body>

</html>
